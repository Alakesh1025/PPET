# -*- coding: utf-8 -*-
"""Parando.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TiSlui_1AWRGR0HEvn340f3nLu305Ovx
"""

import numpy as np
import matplotlib.pyplot as plt
import os
from google.colab import files

p_others=0.3
p_loss=.05


n=list(range(2, 11))
p=[x/101 for x in range (1,100)]
N_c=16
join_time=[]
join_prob=[]
for x in n:
  min=100000000000000
  min_prob=1
  for y in p:
    p_eb=(x*y*((1-y)**(x-1))*((1-p_others)**(x-1))*(1-p_loss))/N_c
    JT=1/p_eb
    if JT< min:
      min=JT
      min_prob=y

  join_time.append(min)
  join_prob.append(min_prob)

fig, ax = plt.subplots()
ax.set_xticks(n)
#print(join_time)
#print(join_prob)
#fig = plt.figure(figsize = (10, 5)) 
# creating the bar plot
plt.bar(n,  join_prob, color ='maroon',
        width = 0.4)
plt.xlabel("Number of joined nodes", fontsize=15)
plt.ylabel("Min. Probablity", fontsize=15)
plt.yticks(fontsize=12)
plt.xticks(fontsize=12)

for index,data in enumerate(join_prob):
    plt.text(x=index+2-.23 , y =data+.01 , s=f"{round(data, 2)}", rotation=0,fontdict=dict(fontsize=10), color="blue")

plt.tight_layout()
plt.savefig('Min_prob.pdf', bbox_inches='tight')
#files.download('Min_prob.pdf')
plt.show()

print('\n')
fig, ax = plt.subplots()
ax.set_xticks(n)
plt.xlabel("Number of joined nodes", fontsize=15)
plt.ylabel("Number of Slotframes", fontsize=15)
plt.bar(n,  join_time, color ='blue', width = 0.4)
plt.yticks(fontsize=12)
plt.xticks(fontsize=12)
for index,data in enumerate(join_time):
    plt.text(x=index+2-.23 , y =data+10 , s=f"{int(data)}", rotation=0,fontdict=dict(fontsize=10), color="maroon")
plt.tight_layout()
plt.savefig('Min_SF.pdf', bbox_inches='tight')
#files.download('Min_SF.pdf')
plt.show()

join_time_low=[] #global join time for low probability
n=list(range(2, 11))
p=.1
N_c=16
join_time=[]
join_prob=[]
for x in n:
  p_eb=(x*p*((1-p)**(x-1))*((1-p_others)**(x-1))*(1-p_loss))/N_c
  JT=1/p_eb
  join_time.append(JT)

fig, ax = plt.subplots()
ax.set_xticks(n)

join_time_low=join_time[:] # copying without reference to global_join_time

plt.bar(n,  join_time, color ='maroon', width = 0.4)
plt.xlabel("Number of joined nodes", fontsize=15)
plt.ylabel("Number of Slotframes", fontsize=15)
plt.yticks(fontsize=12)
plt.xticks(fontsize=12)

for index,data in enumerate(join_time):
    plt.text(x=index+2-.23 , y =data+10 , s=f"{int(data)}", rotation=0,fontdict=dict(fontsize=10), color="blue")

plt.tight_layout()
plt.savefig('Less_Prob.pdf', bbox_inches='tight')
#files.download('Less_Prob.pdf')
plt.show()

charge_l=[]
for x in range (0, len(join_time)):
  charge_l.append(5.9*join_time[x]*1.01)

figg, axx = plt.subplots()
axx.set_xticks(n)


charge_low=charge_l[:]

plt.bar(n,  charge_l, color ='olive', width = 0.4)
plt.xlabel("Number of joined nodes", fontsize=15)
plt.ylabel("Charge consumption (in mC)", fontsize=15)
plt.yticks(fontsize=12)
plt.xticks(fontsize=12)



for index,data in enumerate(charge_l):
    plt.text(x=index+2-.23 , y =data+50, s=f"{int(data)}", rotation=0,fontdict=dict(fontsize=10), color="blue")

plt.tight_layout()
plt.savefig('Less_Prob_charge.pdf', bbox_inches='tight')
#files.download('Less_Prob_charge.pdf')
plt.show()

join_time_high=[] #global join time for low probability
n=list(range(2, 11))
p=.3
N_c=16
join_time=[]
join_prob=[]
for x in n:
  #p=1/x
  p_eb=(x*p*((1-p)**(x-1))*((1-p_others)**(x-1))*(1-p_loss))/N_c
  JT=1/p_eb
  join_time.append(JT)

join_time_high=join_time[:] # copying without reference to global_join_time

fig, ax = plt.subplots()
ax.set_xticks(n)
plt.xlabel("Number of joined nodes", fontsize=15)
plt.ylabel("Number of Slotframes", fontsize=15)
plt.bar(n,  join_time, color ='blue', width = 0.4)
plt.yticks(fontsize=12)
plt.xticks(fontsize=12)
for index,data in enumerate(join_time):
    plt.text(x=index+2-.23 , y =data+30 , s=f"{int(data)}", rotation=0,fontdict=dict(fontsize=10), color="maroon")
plt.tight_layout()
plt.savefig('High_Prob.pdf', bbox_inches='tight')
#files.download('High_Prob.pdf')
plt.show()

charge=[]
for x in range (0, len(join_time)):
  charge.append(5.9*join_time[x]*1.01)

figg, axx = plt.subplots()
axx.set_xticks(n)

charge_high=charge[:]

plt.bar(n,  charge, color ='olive', width = 0.4)
plt.xlabel("Number of joined nodes", fontsize=15)
plt.ylabel("Charge consumption (in mC)", fontsize=15)
plt.yticks(fontsize=12)
plt.xticks(fontsize=12)

for index,data in enumerate(charge):
    plt.text(x=index+2-.23 , y =data+150, s=f"{int(data)}", rotation=0,fontdict=dict(fontsize=10), color="blue")

plt.tight_layout()
plt.savefig('High_Prob_charge.pdf', bbox_inches='tight')
#files.download('High_Prob_charge.pdf')
plt.show()

from re import Pattern
# high and low probability in a single graph

fig, ax = plt.subplots()
ax.set_xticks(n)
plt.xlabel("Number of joined nodes", fontsize=15)
plt.ylabel("Number of Slotframes", fontsize=15)

#plt.bar(n,  join_time_low, color ='blue', width = 0.4)

X_axis = np.array(n)

plt.bar(X_axis - 0.2, join_time_low, 0.4, label = '$P_{eb}=0.1$', hatch='.')
plt.bar(X_axis + 0.2, join_time_high, 0.4, label = '$P_{eb}=0.3$', hatch="-")


for index,data in enumerate(join_time_low):
    plt.text(x=index+2-0.35 , y =data+100 , s=f"{int(data)}", rotation=90,fontdict=dict(fontsize=10), color="maroon")

#lt.bar(n,  join_time_high, color ='blue', width = 0.4)

for index,data in enumerate(join_time_high):
    #plt.text(x=index+2-0.05, y =data+30 , s=f"{int(data)}", rotation=0,fontdict=dict(fontsize=10), color="blue")
    if data< 700:
      plt.text(x=index+2+0.15, y =data+100 , s=f"{int(data)}", rotation=90,fontdict=dict(fontsize=10), color="blue")
    else:  
      plt.text(x=index+2-0.15, y =data+30 , s=f"{int(data)}", rotation=0,fontdict=dict(fontsize=10), color="blue")

plt.legend()
plt.tight_layout()
plt.savefig('High_low_Prob.pdf', bbox_inches='tight')
files.download('High_low_Prob.pdf')
plt.show()  


#charge

plt.xlabel("Number of joined nodes", fontsize=15)
plt.ylabel("Charge consumption (in mC)", fontsize=15)


X_axis = np.array(n)

plt.bar(X_axis - 0.2, charge_low, 0.4, label = '$P_{eb}=0.1$', hatch='.')
plt.bar(X_axis + 0.2, charge_high, 0.4, label = '$P_{eb}=0.3$', hatch="-")


for index,data in enumerate(charge_low):
    plt.text(x=index+2-0.35 , y =data+300 , s=f"{int(data)}", rotation=90,fontdict=dict(fontsize=10), color="maroon")

#lt.bar(n,  join_time_high, color ='blue', width = 0.4)

for index,data in enumerate(charge_high):
    if data< 3500:
      plt.text(x=index+2+0.15, y =data+380 , s=f"{int(data)}", rotation=90,fontdict=dict(fontsize=10), color="blue")
    else:  
      plt.text(x=index+2-0.15, y =data+60 , s=f"{int(data)}", rotation=0,fontdict=dict(fontsize=10), color="blue")

plt.legend()
plt.tight_layout()
plt.savefig('High_low_Prob_charge.pdf', bbox_inches='tight')
files.download('High_low_Prob_charge.pdf')
plt.show()

import random
randomlist=[]
n=list(range(2, 11))
#p=[x/100 for x in range (1,20)]
'''
for i in range(0,len(n)):
  alpha=1/n[i]
  k = random.uniform(.1, alpha)
  randomlist.append(k)
'''
join_time=[]
final_join_time=[]
final_mean_data=[]
mean_data=[]
stand_data=[]
#pp=[.1, .2, .3, .4, .5, .6, .7, .8, .9] #probabilities
pp=[.1,  .3,  .5,  .7,  .9] #probabilities
for xy in pp: #with different probabilities
    
    for loop_k in range(0,1000): # to get mean of 1000 iterations

            for i in range(0,len(n)): 
                k=random.random()
                if k< xy:
                  k=.1
                else:
                  k=.3
                  
                randomlist.append(k)

            #print(randomlist)

            N_c=16
            join_time=[]
            for x in n:
              y=1
              for k in range(1,x-1):
                y=(1-randomlist[k])*y

              p_eb= (x*randomlist[0]*y*(1-p_loss)*((1-p_others)**(x-1)))/N_c 
              JT=1/p_eb
              join_time.append(JT)
              #print(join_time)
            
            randomlist.clear()
            final_join_time.append(join_time)
    
    #print(final_join_time)
    r = list(map(list, np.transpose(final_join_time))) # transpose raw-> column
    #print('Printing below : R')
    #print(len(r))
    
    for xxx in range(0, len(r)):
      m=np.mean(r[xxx])
      mean_data.append(m)
    
    #print('Printing below : Mean_data')
    #print(mean_data)
    r.clear()
    final_join_time.clear()
    hapa=mean_data[:] # without copying into hapa append doesnot work
    final_mean_data.append(hapa)
    #print('Printing below : Mean_data final')
    #print(final_mean_data)
    mean_data.clear()


print(len(final_mean_data))
for f in range(0,len(final_mean_data)):
  y_axis = final_mean_data[f][:]
  x_axis = n
  plt.plot(x_axis, y_axis, label=f"{pp[f]}")

plt.legend()
plt.show()
'''
fig, ax = plt.subplots()
ax.set_xticks(n)
plt.xlabel("Number of joined nodes", fontsize=15)
plt.ylabel("Number of Slotframes", fontsize=15)
plt.bar(n,  join_time, color ='blue', width = 0.4)
plt.yticks(fontsize=12)
plt.xticks(fontsize=12)
plt.show()
'''

#proposed scheme with P_eb=0.3 

import random
import numpy as np
import os
from google.colab import files

final_result=[]
for m in range(0,1000):

      randomlist=[]
      n=list(range(2, 11))
      for i in range(0,len(n)):
            alpha=1/n[i]
          # k = random.uniform(.1, alpha)
            
            
            k=random.random()
            if k< (1-alpha):
              k=.1
            else:
              k=.3 #making it aplha gives better results
              
            randomlist.append(k)

      N_c=16
      join_time=[]
      for x in n:
        y=1
        for k in range(1,x-1):
          y=(1-randomlist[k])*y

        p_eb= (x*randomlist[0]*y*(1-p_loss)*((1-p_others)**(x-1)))/N_c 
        JT=1/p_eb
        join_time.append(JT)


      final_result.append(join_time)

#print(final_result) 


#for x in range(0,len(final_result)):
  #print(final_result[x])


r = list(map(list, np.transpose(final_result))) # transpose raw-> column
mean_data=[]
stand_data=[]
for x in range(0, len(r)):
  m=np.mean(r[x])
  s=np.std(r[x])

  mean_data.append(m)
  stand_data.append(s)


print(mean_data)
'''
x_pos = np.arange(len(r))

# Build the plot
fig, ax = plt.subplots()
ax.bar(x_pos, mean_data, yerr=stand_data, align='center', alpha=.7,color ='yellowgreen', ecolor='red', capsize=5)
ax.set_ylabel('Number of slotframes', fontsize=15)
ax.set_xticks(x_pos)
ax.set_xticklabels(n)
ax.set_xlabel('Joined nodes', fontsize=15)
#ax.yaxis.grid(True)
plt.yticks(fontsize=12)
plt.xticks(fontsize=12)
# Save the figure and show
plt.tight_layout()
plt.savefig('Proposed.pdf', bbox_inches='tight')
#files.download('Proposed.pdf')
plt.show()
'''


fig, ax = plt.subplots()
ax.set_xticks(n)
plt.xlabel("Number of joined nodes", fontsize=15)
plt.ylabel("Number of Slotframes", fontsize=15)
plt.bar(n,  mean_data, color ='blue', width = 0.4)

#y=[]
#for x in mean_data[2:]:
  #y.append(x+80)
#plt.plot(n[2:], y, label = "line 1")


plt.yticks(fontsize=12)
plt.xticks(fontsize=12)

for index,data in enumerate(mean_data):
    plt.text(x=index+2-.23 , y =data+5, s=f"{int(data)}", rotation=0,fontdict=dict(fontsize=10), color="maroon")


plt.tight_layout()
plt.savefig('Proposed.pdf', bbox_inches='tight')


#files.download('Proposed.pdf')
#plt.show()
#print(len(r))

charge=[]
for x in range (0, len(mean_data)):
  charge.append(5.9*mean_data[x]*1.01)

figg, axx = plt.subplots()
axx.set_xticks(n)

plt.bar(n,  charge, color ='olive', width = 0.4)
plt.xlabel("Number of joined nodes", fontsize=15)
plt.ylabel("Charge consumption (in mC)", fontsize=15)
plt.yticks(fontsize=12)
plt.xticks(fontsize=12)

for index,data in enumerate(charge):
    plt.text(x=index+2-.23 , y =data+30, s=f"{int(data)}", rotation=0,fontdict=dict(fontsize=10), color="blue")

plt.tight_layout()
plt.savefig('Proposed_charge.pdf', bbox_inches='tight')
#files.download('Proposed_charge.pdf')
plt.show()

#proposed scheme with P_eb=alpha 

import random
import numpy as np
import os
from google.colab import files

final_result=[]
for m in range(0,1000):

      randomlist=[]
      n=list(range(2, 11))
      for i in range(0,len(n)):
            alpha=1/n[i]
          # k = random.uniform(.1, alpha)
            
            
            k=random.random()
            if k< (1-alpha):
              k=.1
            else:
              k=alpha #making it aplha gives better results
              
            randomlist.append(k)

      N_c=16
      join_time=[]
      for x in n:
        y=1
        for k in range(1,x-1):
          y=(1-randomlist[k])*y

        p_eb= (x*randomlist[0]*y*(1-p_loss)*((1-p_others)**(x-1)))/N_c 
        JT=1/p_eb
        join_time.append(JT)


      final_result.append(join_time)


r = list(map(list, np.transpose(final_result))) # transpose raw-> column
mean_data_alpha=[]
stand_data=[]
for x in range(0, len(r)):
  m=np.mean(r[x])
  s=np.std(r[x])

  mean_data_alpha.append(m)
  stand_data.append(s)


print(mean_data_alpha)


fig, ax = plt.subplots()
ax.set_xticks(n)
plt.xlabel("Number of joined nodes", fontsize=15)
plt.ylabel("Number of Slotframes", fontsize=15)
plt.bar(n,  mean_data_alpha, color ='blue', width = 0.4)


plt.yticks(fontsize=12)
plt.xticks(fontsize=12)

for index,data in enumerate(mean_data_alpha):
    plt.text(x=index+2-.23 , y =data+5, s=f"{int(data)}", rotation=0,fontdict=dict(fontsize=10), color="maroon")


plt.tight_layout()
plt.savefig('Proposed_alpha.pdf', bbox_inches='tight')


#files.download('Proposed.pdf')
#plt.show()
#print(len(r))

#parando's jointime
for f in range(0,len(final_mean_data)): #data from running 1000 times using Parando's Paradox
  y_axis = final_mean_data[f][:]
  x_axis = n
  plt.plot(x_axis, y_axis, label=r'$\beta$='f"{pp[f]}")

plt.plot(x_axis, mean_data,'b:^' ,label=r'$\alpha$',linewidth = '3') # join mean time using alpha. <--- mead_data
plt.plot(x_axis, mean_data_alpha,'r-o' ,label=r'$\alpha-improved$',linewidth = '3') #improved_peb=alpha
plt.plot(x_axis, join_time_low,'g--' ,label='$P_{eb}=0.1$',linewidth = '3',color='black')
plt.plot(x_axis, join_time_high,':' ,label='$P_{eb}=0.3$',linewidth = '3')

plt.xlabel("Number of joined nodes", fontsize=15)
plt.ylabel("Number of Slotframes", fontsize=15)
plt.yticks(fontsize=12)
plt.xticks(fontsize=12)
plt.legend()
plt.tight_layout()
plt.savefig('parando_join.pdf', bbox_inches='tight')
files.download('parando_join.pdf')
plt.show()

#parando's jointime
for f in range(0,len(final_mean_data)): #data from running 1000 times using Parando's Paradox
  y_axis = final_mean_data[f][:]
  y_axis_new= [i * 5.9*1.01 for i in y_axis]
  x_axis = n
  plt.plot(x_axis, y_axis_new, label=r'$\beta$='f"{pp[f]}")

plt.plot(x_axis, [i * 5.9*1.01 for i in mean_data],'b:^' ,label=r'$\alpha$',linewidth = '3') # join mean time using alpha. <--- mead_data
plt.plot(x_axis, [i * 5.9*1.01 for i in mean_data_alpha],'r-o' ,label=r'$\alpha-improved$',linewidth = '3')
plt.plot(x_axis, [i * 5.9*1.01 for i in join_time_low],'g--' ,label='$P_{eb}=0.1$',linewidth = '3',color='black')
plt.plot(x_axis, [i * 5.9*1.01 for i in join_time_high],':' ,label='$P_{eb}=0.3$',linewidth = '3')

plt.xlabel("Number of joined nodes", fontsize=15)
plt.ylabel("Charge consumption (in mC)", fontsize=15)
plt.yticks(fontsize=12)
plt.xticks(fontsize=12)
plt.legend()
plt.tight_layout()
plt.savefig('parando_charge.pdf', bbox_inches='tight')
files.download('parando_charge.pdf')
plt.show()